# 程序员的修炼之道——从小工到专家

## 一、注重实效的哲学 A Pragmatic Philosophy

### 1. 我的源码让猫给吃了

> - 提供各种选择，不要找蹩脚的理由 Provide Options, Don't Make Lame Excuses

### 2. 软件的熵

> - 不要容忍破窗户 Don't Live with Broken Windows

### 3. 石头汤与煮青蛙

> - 做变化的催化剂 Be a Catalyst for Change

设计出可以合理要求的东西，好好开发后，一旦完成，就拿给大家看，让他们意识到：要是我们增加...可能就会变更好。

> - 记住大图景 Remember the Big Picture

不要像青蛙一样，要注意留心大图景，持续不断地观察周围发生的事情。而不只是做自己的事情。

**思考：** 当你催生变化时，你是否能确定是在做石头汤还是在煮青蛙？决策是主观还是客观的？

### 4. 足够好的软件

> - 让你的用户参与权衡，使质量成为需求问题 Make Quality a Requirements Issue

为赶上最后期限而削减基本的工作内通，这不是有职业素养的做法。

> - 知道何时止步

不要因为过度修饰和过于求精而毁损完好的程序。

**思考：** 模块化设计和整体式设计，达到所需的质量，何者花费时间更少？

### 5. 你的知识资产

> - 定期为你的知识资产投资 Invest Regularly in Your Knowledge Portfolio

> - 批判的分析你读到的和听到的 Critically Analyze What You Read and Hear

### 6. 交流

> - 知道你想要说什么

规划你想要说的东西，写出大纲，然后问自己：“这是否讲清楚了我要说的所有内容？”提炼它，直到确实如此。

> - 了解你的听众

> - 让听众参与、做倾听者、回复他人

反馈也是交流的一种形式。
即使内容知识“我稍后回复你”，也应当总是做出回应。

## 二、注重实效的途径

### 7. 重复的危害

可靠的开发软件，并让开发更加易于理解和维护的唯一途径，是遵循`DRY`原则：
**系统中的每一项知识都必须是具有单一、无歧义、权威的表示。**

> - 不要重复你自己 DRY - Don't Repeat Yourself

好代码有许多注释，糟糕的代码才**需要**许多注释。

> - 让复用变得容易 Make It Easy to Reuse

如果不容易，大家就不会去复用。

### 8. 正交性

在计算技术中，**正交性**用于表示某种不相依赖性或是解耦性。

> - 消除无关事物之间的影响 Eliminate Effects Between Unrelated Things

要设计自足（self-contained）的组件：独立，具有单一、良好定义的目的（或称为**内聚**（cohesion））。
编写正交系统的两个主要好处：**提高生产率**和**降低风险**。

分层也降低了模块间依赖关系失控的风险。一旦设计好组建，问问你自己：如果我显著的改变某个特定功能背后的需求，有多少模块会受影响？

关于代码，可以用若干技术用于维持正交性：
- 保持代码解耦
- 避免使用全局数据
- 避免编写相似的函数

遇到问题时，评估修正的局部化程度。

### 9. 可撤销性

> - 如果某个想法是你唯一的想法，再没有什么比这更危险的事情了。
> - 不存在最终决策 There Are No Finial Decisions

### 10. 曳光弹
> - 用曳光弹找到目标 Use Tracer Bullets to Find the Target

曳光代码方法有许多优点：
- 用户能够及早看到能工作的东西
- 开发者构建了一个他们能在其中工作的结构
- 你有了一个集成平台
- 你有了可用于演示的东西
- 你将更能够感觉到工作进展

曳光弹告诉你击中的是什么，那不一定是目标。于是你调整准星，直到完全击中目标为止。这正是要点所在。

**曳光代码 VS 原型制作：**
原型制作生成用过就扔的代码。曳光代码虽然简约，但却是完整的，并且构成了最终系统骨架的一部分。

### 11. 原型与便笺
如果你发现自己处在不能放弃细节的环境中，就需要问自己，是否真的在构建原型。或许曳光弹开发方式更适合这种情况。
>- 为了学习而制作原型 Prototype to Learn

在构建原型时，可以忽略：**正确性**、**完整性**、**健壮性**、**风格**

思考：耦合是否得以最小化

### 12. 领域语言
>- 语言的界限就是一个人的世界的界限
>- 靠近问题领域编程 Program Close to the Problem Domain

### 13. 估算
在进行估算的过程中，你将会加深对你的程序所处世界的理解。
>- 估算，以避免发生意外 Estimate to Avoid Suprise

当有人要你进行估算时，你要问自己的第一个问题就是：你解答问题的语境是什么？要选择你想要传达的精确度的单位。
- 多准确才算准确
- 估算来自哪里
- 理解提问内容
- 建立系统的模型
- 把模型分解为组件
- 给每个参数指定值
- 计算答案
  - 在计算阶段，你可能会得到看起来很奇怪的答案。不要太快放弃他们，如果你的运算是正确的，那你对问题或模型的理解就恨何能时错的。这是非常宝贵的信息。
- 追踪你的估算能力
- 估算项目进度
>-通过代码对进度进行迭代 Iterate the Schedule with the Code

- 在被要求进行估算时说什么

## 三、基本工具
### 14. 纯文本的威力
>- 用纯文本保存知识 Keep Knowledge in Plain Text

**缺点**
- 与压缩的二进制格式相比，所需空间更多
- 要解释及处理纯文本文件，计算上的代价可能更昂贵

**优点**
- 保证不过时
- 杠杆作用
  - Unix哲学：提供“锋利”的小工具、其中每一样都意在把一件事情做好。
  - 该哲学通过使用公共的底层格式得以实行：面向行的纯文本文件。
- 更易于测试

### 15. shell游戏 🌟🌟
>- 利用命令shell的力量 Use the Power of Commend Shells

### 16. 强力编辑 🌟
>- 用好一种编辑器 Use a Single Editor Well

### 17. 源码控制
>- 总是使用源码控制 Always Use Source Code Control

### 18. 调试
>- 要修正问题，而不是发出指责 Fix the Problem, Not the Blame
>- 不要恐慌 Don't Panic

## 四、注重实效的偏执

## 五、弯曲或折断

## 六、当你编码时

## 七、在项目开始之前

## 八、注重实效的项目
